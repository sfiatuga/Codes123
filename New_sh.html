<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Devtraco Estate Navigation</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css"/>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; font-family: Arial, sans-serif; }

    .navbar {
      position: absolute; top: 10px; right: 20px; z-index: 1000;
    }
    .navbar a {
      background: #007bff; color: white; padding: 8px 15px;
      margin-left: 10px; text-decoration: none; border-radius: 4px;
      transition: 0.3s;
    }
    .navbar a:hover { background: #0056b3; }

    .page { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .active { display: block; }

    #home {
      background: url('https://devtraco.com/wp-content/uploads/2021/01/Untitled-design-2.jpg') center/cover no-repeat;
      display: flex; flex-direction: column; justify-content: flex-start; align-items: center;
      text-align: center; color: white; padding-top: 80px;
    }
    #home h1 {
      font-size: 3em; margin-bottom: 10px;
      color: #ffcc00;
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8);
    }
    #home p { max-width: 600px; font-size: 1.2em; padding: 0 20px; margin-bottom: 20px; color: white; }
    button {
      padding: 15px 25px; background: #28a745; color: white;
      border: none; border-radius: 5px; cursor: pointer;
    }
    button:hover { background: #1e7e34; }

    #about {
      background: url('https://devtraco.com/wp-content/uploads/2021/01/Untitled-design-1.jpg') center/cover no-repeat;
      color: white;
      position: relative;
    }
    #about::before {
      content: "";
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      z-index: 1;
    }
    #about .content {
      position: relative;
      z-index: 2;
      padding: 80px 40px;
    }

    #contact {
      background: #2c3e50; color: white; padding: 80px 40px;
    }

    #mapPage { background: white; color: #333; }
    #map { height: 100%; width: 100%; }

    .return-btn {
      position: absolute; top: 80px; left: 10px; z-index: 1000;
      background: #dc3545; color: white; border: none;
      padding: 8px 15px; border-radius: 4px;
    }

    .search-bar {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: white;
      padding: 8px;
      border-radius: 4px;
      display: flex;
      gap: 8px;
      align-items: center;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .search-bar input {
      padding: 10px;
      width: 500px;
      font-size: 1em;
      border: 1px solid #ccc;
      border-radius: 3px;
    }
    .search-bar button {
      padding: 10px 15px; background: #007bff; color: white;
      border: none; border-radius: 3px; font-size: 1em;
    }

    .leaflet-routing-container {
      margin-top: 120px !important;
    }

    .blinking {
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .gps-accuracy {
      stroke: #0078A8;
      fill: #0078A8;
      fill-opacity: 0.2;
      pointer-events: none;
    }

    .loading-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      border: 5px solid rgba(243, 243, 243, 0.8);
      border-top: 5px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      background-color: rgba(255,255,255,0.8);
      display: none;
    }

    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    .recenter-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background: #007bff;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    .voice-controls {
      position: absolute;
      bottom: 70px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .voice-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    
    #search-results {
      position: absolute;
      top: 100%;
      left: 0;
      width: 100%;
      max-height: 300px;
      overflow-y: auto;
      background: white;
      border: 1px solid #ccc;
      border-radius: 0 0 4px 4px;
      z-index: 1001;
      display: none;
    }
    .search-result {
      padding: 10px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
    }
    .search-result:hover {
      background-color: #f5f5f5;
    }

    .route-line {
      stroke: #0066ff;
      stroke-width: 5;
      stroke-opacity: 0.8;
      stroke-dasharray: 10, 10;
      animation: dash 1.5s linear infinite;
    }

    @keyframes dash {
      0% { stroke-dashoffset: 20; }
      100% { stroke-dashoffset: 0; }
    }

    .route-line-upcoming {
      stroke: #66ccff;
      stroke-width: 4;
      stroke-opacity: 0.5;
    }

    .route-direction-marker {
      transition: transform 0.5s ease;
    }

    @media (max-width: 768px) {
      .search-bar {
        width: 90%;
      }
      .search-bar input {
        width: 100%;
      }
      .navbar {
        top: 5px;
        right: 5px;
      }
      .navbar a {
        padding: 5px 10px;
        font-size: 0.9em;
      }
    }
  </style>
</head>
<body>

<div class="navbar" id="navLinks">
  <a href="#" onclick="show('home')">Home</a>
  <a href="#" onclick="show('about')">About</a>
  <a href="#" onclick="show('contact')">Contact</a>
</div>

<div id="home" class="page active">
  <h1>Welcome to Devtraco Estate</h1>
  <p>Explore Devtraco with live GPS navigation, voice-guided directions, and seamless search functionality.</p>
  <button onclick="show('map')">Start Navigation</button>
</div>

<div id="about" class="page">
  <div class="content">
    <h2>About Devtraco Estate</h2>
    <p>Devtraco Estate is a premier residential community located in the serene area of Tema Community 25, Accra, Ghana. It offers high-quality housing units with modern amenities, reliable security systems, excellent roads, and access to schools, hospitals, and shopping centers.</p>
    <p>Visit: <a href="https://devtraco.com" target="_blank" style="color: #ffcc00;">https://devtraco.com</a></p>
    <button onclick="show('home')">Return</button>
  </div>
</div>

<div id="contact" class="page">
  <div class="content">
    <h2>Contact Us</h2>
    <p>
      For inquiries and support:<br>
      üìß Email: info@devtraco.com<br>
      ‚òé Phone: +233‚ÄØ302‚ÄØ812‚ÄØ000<br>
      üìç Address: Devtraco Courts, Community 25, Tema, Ghana
    </p>
    <button onclick="show('home')">Return</button>
  </div>
</div>

<div id="mapPage" class="page">
  <button class="return-btn" onclick="show('home')">&larr; Back</button>
  <div class="search-bar">
    <input type="text" id="searchInput" placeholder="Search house number or location in Ghana"/>
    <button onclick="doSearch()">Search</button>
    <div id="search-results"></div>
  </div>
  <div id="map"></div>
  <div id="loadingSpinner" class="loading-spinner" style="display: none;"></div>
  <div class="voice-controls">
    <button class="voice-btn" onclick="repeatInstruction()" title="Repeat instruction">üîä</button>
  </div>
  <button class="recenter-btn" onclick="recenterMap()" title="Recenter on my location">üìç</button>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.min.js"></script>

<script>
  // Global variables
  let map, routingControl, userMarker, accuracyCircle, userPos = [], instructions = [];
  let watchId = null;
  let lastSpokenInstruction = null;
  let nextInstructionIndex = 0;
  let isNavigating = false;
  let houseData = [];
  let roadData = [];
  let highlightedHouse = null;
  let routeDirectionMarker = null;
  let dataLoaded = false;
  let animationFrameId = null;

  // Estate bounds
  const estateBounds = {
    minLat: 5.7260,
    maxLat: 5.7400,
    minLon: 0.0390,
    maxLon: 0.0500
  };

  // Speech synthesis function
  function speak(text) {
    if (!window.speechSynthesis) {
      console.warn("Speech synthesis not supported");
      return;
    }
    
    try {
      window.speechSynthesis.cancel();
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = 'en-US';
      utter.rate = 0.9;
      utter.pitch = 1.1;
      
      if (/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        utter.rate = 1.0;
        utter.volume = 1.5;
      }
      
      window.speechSynthesis.speak(utter);
    } catch (error) {
      console.error("Speech synthesis error:", error);
    }
  }

  // Show page function
  function show(id) {
    document.querySelectorAll('.page').forEach(e => e.classList.remove('active'));
    document.getElementById(id === 'map' ? 'mapPage' : id).classList.add('active');
    document.getElementById('navLinks').style.display = (id === 'map') ? 'none' : 'block';
    
    if (id === 'map') {
      setTimeout(() => {
        if (!map) initMap();
        else recenterMap();
      }, 300);
    } else {
      // Clean up map resources when leaving map page
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }
  }

  // Location error handler
  function handleLocationError(error) {
    let errorMsg = "Error getting your location: ";
    switch(error.code) {
      case error.PERMISSION_DENIED:
        errorMsg += "Location permission denied. Please enable it in your browser settings.";
        break;
      case error.POSITION_UNAVAILABLE:
        errorMsg += "Location information unavailable.";
        break;
      case error.TIMEOUT:
        errorMsg += "Location request timed out. Please try again.";
        break;
      case error.UNKNOWN_ERROR:
        errorMsg += "An unknown error occurred.";
        break;
    }
    console.error(errorMsg);
    
    // Default to estate center if location fails
    userPos = [5.7328, 0.0447];
    if (userMarker) {
      userMarker.setLatLng(userPos);
    } else {
      const customIcon = L.icon({
        iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        className: 'blinking'
      });
      userMarker = L.marker(userPos, { icon: customIcon }).addTo(map);
    }
    map.setView(userPos, 15);
    speak("Using default location. Please enable GPS for accurate navigation.");
  }

  // Initialize map
  function initMap() {
    if (map) return;

    document.getElementById('loadingSpinner').style.display = 'block';

    map = L.map('map', {
      zoomControl: false,
      preferCanvas: true
    }).setView([5.7328, 0.0447], 14);

    // Add zoom control with better position
    L.control.zoom({
      position: 'topright'
    }).addTo(map);

    const streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap contributors'
    });

    const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: '¬© Esri, Maxar, Earthstar Geographics'
    });

    const labelsLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}.png', {
      attribution: '¬© CartoDB'
    });

    const baseLayers = {
      "Street": streetLayer,
      "Satellite with Labels": L.layerGroup([satelliteLayer, labelsLayer])
    };

    streetLayer.addTo(map);
    L.control.layers(baseLayers).addTo(map);

    // Load estate data
    Promise.all([
      loadGeoJSON('POINTS.json', 'house'),
      loadGeoJSON('ROAD.json', 'road')
    ]).then(() => {
      dataLoaded = true;
      document.getElementById('loadingSpinner').style.display = 'none';
    }).catch(error => {
      console.error('Error loading data:', error);
      document.getElementById('loadingSpinner').style.display = 'none';
      speak("Error loading map data. Some features may not work properly.");
    });

    // Initialize routing control
    initRoutingControl();

    // Setup geolocation
    setupGeolocation();

    // Setup search functionality
    setupSearch();
  }

  // Load GeoJSON data
  function loadGeoJSON(url, type) {
    return fetch(url)
      .then(response => {
        if (!response.ok) throw new Error(`Failed to load ${type} GeoJSON`);
        return response.json();
      })
      .then(data => {
        if (type === 'house') {
          houseData = data.features || [];
        } else if (type === 'road') {
          roadData = data.features || [];
        }
      })
      .catch(error => {
        console.error(`Error loading ${type} data:`, error);
        // Fallback sample data
        if (type === 'house') {
          houseData = [{
            type: "Feature",
            properties: { name: "Sample Building", type: "building", HOUSE_NUMB: "A1" },
            geometry: {
              type: "Point",
              coordinates: [0.0447, 5.7328]
            }
          }];
        } else if (type === 'road') {
          roadData = [
            {
              type: "Feature",
              properties: { name: "Main Estate Road", type: "road", ROAD_ID: "R1" },
              geometry: {
                type: "LineString",
                coordinates: [
                  [0.0445, 5.7328],
                  [0.0447, 5.7328],
                  [0.0449, 5.7327]
                ]
              }
            }
          ];
        }
      });
  }

  // Initialize routing control
  function initRoutingControl() {
    routingControl = L.Routing.control({
      waypoints: [],
      routeWhileDragging: false,
      collapsible: true,
      show: false,
      createMarker: () => null,
      formatter: new L.Routing.Formatter({
        language: 'en',
        units: 'metric'
      }),
      router: L.Routing.osrmv1({
        serviceUrl: 'https://router.project-osrm.org/route/v1',
        timeout: 5000,
        profile: 'driving'
      }),
      plan: L.Routing.plan([], {
        draggableWaypoints: false,
        addWaypoints: false
      }),
      lineOptions: {
        styles: [
          { className: 'route-line', weight: 5, opacity: 0.8 },
          { className: 'route-line-upcoming', weight: 4, opacity: 0.5 }
        ]
      }
    }).addTo(map);

    // Routing events
    routingControl.on('routestart', function() {
      document.getElementById('loadingSpinner').style.display = 'block';
    });

    routingControl.on('routesfound', function(e) {
      document.getElementById('loadingSpinner').style.display = 'none';
      const routes = e.routes;
      instructions = routes[0].instructions;
      nextInstructionIndex = 0;
      isNavigating = true;
      
      if (instructions.length > 0) {
        speakInstruction(instructions[0]);
        nextInstructionIndex = 1;
      }
      
      const distance = (routes[0].summary.totalDistance / 1000).toFixed(1);
      speak(`Route calculated. Your destination is ${distance} kilometers away.`);
      animateRouteDirection(routes[0].coordinates);
    });

    routingControl.on('routingerror', function(e) {
      document.getElementById('loadingSpinner').style.display = 'none';
      speak("Unable to calculate route. Please try a different location or check your connection.");
      console.error("Routing error:", e.error);
    });

    // Pre-warm routing engine
    setTimeout(() => {
      const dummyStart = [5.7328, 0.0447];
      const dummyEnd = [5.7330, 0.0449];
      routingControl.setWaypoints([
        L.latLng(dummyStart[0], dummyStart[1]),
        L.latLng(dummyEnd[0], dummyEnd[1])
      ]);
      setTimeout(() => routingControl.setWaypoints([]), 100);
    }, 500);
  }

  // Setup geolocation
  function setupGeolocation() {
    const geoOptions = {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    };

    navigator.geolocation.getCurrentPosition(
      (p) => {
        updateUserPosition(p);
        document.getElementById('loadingSpinner').style.display = 'none';
      },
      handleLocationError,
      geoOptions
    );

    watchId = navigator.geolocation.watchPosition(
      updateUserPosition,
      handleLocationError,
      geoOptions
    );
  }

  // Update user position
  function updateUserPosition(position) {
    const lat = position.coords.latitude;
    const lon = position.coords.longitude;
    const accuracy = position.coords.accuracy;
    
    userPos = [lat, lon];
    
    const customIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      className: 'blinking'
    });

    if (userMarker) {
      userMarker.setLatLng(userPos);
    } else {
      userMarker = L.marker(userPos, { icon: customIcon }).addTo(map);
    }

    if (accuracyCircle) {
      accuracyCircle.setLatLng(userPos).setRadius(accuracy);
    } else {
      accuracyCircle = L.circle(userPos, {
        radius: accuracy,
        className: 'gps-accuracy'
      }).addTo(map);
    }

    if (isNavigating && instructions.length > 0) {
      checkNextInstruction();
    }
  }

  // Check next navigation instruction
  function checkNextInstruction() {
    if (!isNavigating || nextInstructionIndex >= instructions.length) return;

    const currentInstruction = instructions[nextInstructionIndex];
    const distanceToNext = map.distance(userPos, currentInstruction.latLng);

    if (distanceToNext < 50) {
      speakInstruction(currentInstruction);
      nextInstructionIndex++;
      
      if (nextInstructionIndex < instructions.length) {
        const nextInstruction = instructions[nextInstructionIndex];
        const nextDistance = map.distance(userPos, nextInstruction.latLng);
        
        if (nextDistance < 150) {
          speak(`After that, ${nextInstruction.text}`);
        }
      }
    } else if (nextInstructionIndex === instructions.length - 1 && distanceToNext < 20) {
      speak("You have arrived at your destination");
      isNavigating = false;
      if (routeDirectionMarker) {
        map.removeLayer(routeDirectionMarker);
        routeDirectionMarker = null;
      }
    }
  }

  // Speak navigation instruction
  function speakInstruction(instruction) {
    let text = instruction.text;
    
    // Improve instruction phrasing
    const replacements = {
      'Continue': 'Continue for',
      'Destination': 'You have reached your destination',
      'left': 'Turn left',
      'right': 'Turn right',
      'sharp left': 'Take a sharp left',
      'sharp right': 'Take a sharp right',
      'slight left': 'Bear left',
      'slight right': 'Bear right'
    };
    
    for (const [key, value] of Object.entries(replacements)) {
      text = text.replace(new RegExp(key, 'g'), value);
    }
    
    if (instruction.distance > 0) {
      const distance = instruction.distance < 1000 ? 
        `${Math.round(instruction.distance)} meters` : 
        `${(instruction.distance / 1000).toFixed(1)} kilometers`;
      text = `In ${distance}, ${text}`;
    }
    
    speak(text);
    lastSpokenInstruction = text;
  }

  // Repeat last instruction
  function repeatInstruction() {
    if (lastSpokenInstruction) {
      speak(lastSpokenInstruction);
    } else {
      speak("No instructions available");
    }
  }

  // Recenter map on user
  function recenterMap() {
    if (userPos.length) {
      map.setView(userPos, 15);
    }
  }

  // Setup search functionality
  function setupSearch() {
    const searchInput = document.getElementById('searchInput');
    const searchResults = document.getElementById('search-results');
    
    searchInput.addEventListener('input', (e) => {
      const searchTerm = e.target.value.trim().toUpperCase();
      searchResults.innerHTML = '';
      
      if (searchTerm.length < 1) {
        searchResults.style.display = 'none';
        return;
      }
      
      const houseMatches = houseData.filter(house => 
        house.properties.HOUSE_NUMB && 
        house.properties.HOUSE_NUMB.toUpperCase().includes(searchTerm)
      ).slice(0, 5);
      
      houseMatches.forEach(house => {
        const resultItem = document.createElement('div');
        resultItem.className = 'search-result';
        resultItem.textContent = house.properties.HOUSE_NUMB;
        resultItem.addEventListener('click', () => {
          selectHouse(house);
          searchResults.style.display = 'none';
          searchInput.value = house.properties.HOUSE_NUMB;
        });
        searchResults.appendChild(resultItem);
      });
      
      if (houseMatches.length > 0) {
        searchResults.style.display = 'block';
      } else {
        searchResults.style.display = 'none';
      }
    });
    
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.search-bar')) {
        searchResults.style.display = 'none';
      }
    });
  }

  // Perform search
  function doSearch() {
    const q = document.getElementById('searchInput').value.trim();
    if (!q || !userPos.length) {
      speak("Please enter a search term and ensure location services are enabled.");
      return;
    }
    
    // First check house numbers
    const houseMatch = houseData.find(house => 
      house.properties.HOUSE_NUMB && 
      house.properties.HOUSE_NUMB.toUpperCase() === q.toUpperCase()
    );
    
    if (houseMatch) {
      selectHouse(houseMatch);
      return;
    }
    
    // If not a house number, search OSM
    document.getElementById('loadingSpinner').style.display = 'block';
    
    fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q + ' Ghana')}`)
      .then(res => {
        if (!res.ok) throw new Error('Search failed');
        return res.json();
      })
      .then(data => {
        document.getElementById('loadingSpinner').style.display = 'none';
        if (!data.length) {
          speak("Location not found. Please try another search term.");
          return;
        }
        const dest = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
        
        if (isInEstate(dest[0], dest[1])) {
          const waypoints = getRoadWaypoints(userPos, dest);
          routingControl.setWaypoints(waypoints);
          map.setView(dest, 15);
          speak(`Routing to ${q} via estate roads`);
        } else {
          routingControl.setWaypoints([
            L.latLng(userPos[0], userPos[1]),
            L.latLng(dest[0], dest[1])
          ]);
          map.setView(dest, 15);
          speak(`Routing to ${q}`);
        }
      })
      .catch(err => {
        document.getElementById('loadingSpinner').style.display = 'none';
        console.error('Search error:', err);
        speak("Error searching for location. Please try again.");
      });
  }

  // Check if location is within estate bounds
  function isInEstate(lat, lon) {
    return lat >= estateBounds.minLat && lat <= estateBounds.maxLat &&
           lon >= estateBounds.minLon && lon <= estateBounds.maxLon;
  }

  // Find nearest road point
  function findNearestRoadPoint(lat, lon) {
    if (!roadData.length) return { point: null, roadName: '', distance: Infinity };

    let minDistance = Infinity;
    let nearestPoint = null;
    let nearestRoadName = '';
    const maxSnapDistance = 50; // Max snapping distance in meters

    roadData.forEach(road => {
      if (road.geometry.type === 'LineString') {
        road.geometry.coordinates.forEach(coord => {
          const distance = map.distance([lat, lon], [coord[1], coord[0]]);
          if (distance < minDistance && distance <= maxSnapDistance) {
            minDistance = distance;
            nearestPoint = [coord[1], coord[0]]; // [lat, lon]
            nearestRoadName = road.properties.name || road.properties.ROAD_ID || 'road';
          }
        });
      }
    });

    return { point: nearestPoint, roadName: nearestRoadName, distance: minDistance };
  }

  // Get road waypoints for routing
  function getRoadWaypoints(startLatLng, endLatLng) {
    const waypoints = [];
    
    // Snap start point to road if in estate
    if (isInEstate(startLatLng[0], startLatLng[1])) {
      const nearestStart = findNearestRoadPoint(startLatLng[0], startLatLng[1]);
      if (nearestStart.point && nearestStart.distance <= 50) {
        waypoints.push(L.latLng(nearestStart.point[0], nearestStart.point[1]));
        speak(`Starting from ${nearestStart.roadName}`);
      } else {
        waypoints.push(L.latLng(startLatLng[0], startLatLng[1]));
        speak("Starting from your current location, no nearby road found.");
      }
    } else {
      waypoints.push(L.latLng(startLatLng[0], startLatLng[1]));
    }

    // Add intermediate waypoints for estate roads if both points are in estate
    if (isInEstate(startLatLng[0], startLatLng[1]) && isInEstate(endLatLng[0], endLatLng[1])) {
      const midRoad = roadData.find(road => road.properties.ROAD_ID === 'R1'); // Example: Use main road
      if (midRoad && midRoad.geometry.type === 'LineString') {
        const midPoint = midRoad.geometry.coordinates[Math.floor(midRoad.geometry.coordinates.length / 2)];
        waypoints.push(L.latLng(midPoint[1], midPoint[0]));
      }
    }

    // Snap end point to road if in estate
    if (isInEstate(endLatLng[0], endLatLng[1])) {
      const nearestEnd = findNearestRoadPoint(endLatLng[0], endLatLng[1]);
      if (nearestEnd.point && nearestEnd.distance <= 50) {
        waypoints.push(L.latLng(nearestEnd.point[0], nearestEnd.point[1]));
        speak(`Heading to ${nearestEnd.roadName}`);
      } else {
        waypoints.push(L.latLng(endLatLng[0], endLatLng[1]));
        speak("Heading to destination, no nearby road found.");
      }
    } else {
      waypoints.push(L.latLng(endLatLng[0], endLatLng[1]));
    }

    return waypoints;
  }

  // Select a house
  function selectHouse(house) {
    if (highlightedHouse) {
      map.removeLayer(highlightedHouse);
    }
    
    const houseCoords = house.geometry.coordinates;
    const houseLatLng = [houseCoords[1], houseCoords[0]];

    map.flyTo(houseLatLng, 18);

    const houseIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
      shadowSize: [41, 41]
    });
    highlightedHouse = L.marker(houseLatLng, { icon: houseIcon })
      .addTo(map)
      .bindPopup(`<b>House:</b> ${house.properties.HOUSE_NUMB}`)
      .openPopup();

    if (userPos.length) {
      if (routingControl) {
        map.removeControl(routingControl);
      }

      const waypoints = getRoadWaypoints(userPos, houseLatLng);

      routingControl = L.Routing.control({
        waypoints: waypoints,
        routeWhileDragging: false,
        showAlternatives: false,
        addWaypoints: false,
        draggableWaypoints: false,
        fitSelectedRoutes: true,
        lineOptions: {
          styles: [
            { className: 'route-line', weight: 5, opacity: 0.8 },
            { className: 'route-line-upcoming', weight: 4, opacity: 0.5 }
          ]
        },
        createMarker: function() { return null; }
      }).addTo(map);
      
      speak(`Routing to house ${house.properties.HOUSE_NUMB} via estate roads`);
    } else {
      speak("Please enable location services to get directions.");
    }
  }

  // Animate route direction
  function animateRouteDirection(coordinates) {
    if (routeDirectionMarker) {
      map.removeLayer(routeDirectionMarker);
    }

    if (!coordinates || coordinates.length === 0) return;

    const directionIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
      iconSize: [20, 32],
      iconAnchor: [10, 32],
      className: 'route-direction-marker'
    });

    let index = 0;
    routeDirectionMarker = L.marker([coordinates[0].lat, coordinates[0].lng], { 
      icon: directionIcon,
      zIndexOffset: 1000
    }).addTo(map);

    function moveMarker() {
      if (!isNavigating || index >= coordinates.length - 1) {
        if (routeDirectionMarker) {
          map.removeLayer(routeDirectionMarker);
          routeDirectionMarker = null;
        }
        return;
      }

      index++;
      routeDirectionMarker.setLatLng([coordinates[index].lat, coordinates[index].lng]);
      animationFrameId = requestAnimationFrame(moveMarker);
    }

    animationFrameId = requestAnimationFrame(moveMarker);
  }

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    if (watchId) {
      navigator.geolocation.clearWatch(watchId);
    }
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }
    window.speechSynthesis.cancel();
  });

  // Initialize the app when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    // Check for geolocation support
    if (!navigator.geolocation) {
      alert("Geolocation is not supported by your browser. Some features may not work properly.");
    }
    
    // Check for speech synthesis support
    if (!window.speechSynthesis) {
      console.warn("Speech synthesis not supported");
    }
  });
</script>
</body>
</html>